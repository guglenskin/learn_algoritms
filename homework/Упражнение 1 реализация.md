üßÆ –£–ø—Ä–∞–∂–Ω–µ–Ω–∏—è –ø–æ –ø–æ–∏—Å–∫—É –∫–æ–Ω—Ç—Ä–ø—Ä–∏–º–µ—Ä–æ–≤
1. –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –¥–ª—è a + b < min(a, b)
```
#include <iostream>
#include <algorithm>

int main() {
    int a = -2, b = -3;
    std::cout << "a + b = " << a + b << " < min(a,b) = " << std::min(a, b) << std::endl;
    return 0;
}
–û–±—ä—è—Å–Ω–µ–Ω–∏–µ: –î–ª—è –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª —Å—É–º–º–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∏–∑ –Ω–∏—Ö.
```
2. –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –¥–ª—è a * b < min(a, b)
```
#include <iostream>
#include <algorithm>

int main() {
    int a = 0.5, b = 0.4; // –í C++ –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å float/double
    std::cout << "a * b = " << a * b << " < min(a,b) = " << std::min(a, b) << std::endl;
    return 0;
}
```
–û–±—ä—è—Å–Ω–µ–Ω–∏–µ: –î–ª—è –¥—Ä–æ–±–Ω—ã—Ö —á–∏—Å–µ–ª –º–µ–∂–¥—É 0 –∏ 1 –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –º–µ–Ω—å—à–µ –ª—é–±–æ–≥–æ –∏–∑ –º–Ω–æ–∂–∏—Ç–µ–ª–µ–π.
3. –°–µ—Ç—å –¥–æ—Ä–æ–≥ —Å –∫—Ä–∞—Ç—á–∞–π—à–∏–º –≤—Ä–µ–º–µ–Ω–µ–º ‚â† –∫—Ä–∞—Ç—á–∞–π—à–µ–º—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
```
#include <vector>
#include <algorithm>

struct Road {
    int from, to;
    int distance; // –≤ –∫–º
    int speed;    // –∫–º/—á
    double time() const { return (double)distance / speed; }
};

int main() {
    std::vector<Road> roads = {
        {0, 1, 10, 50}, // –î–ª–∏–Ω–Ω–∞—è, –Ω–æ –±—ã—Å—Ç—Ä–∞—è –¥–æ—Ä–æ–≥–∞
        {0, 2, 2, 10},  // –ö–æ—Ä–æ—Ç–∫–∏–µ –º–µ–¥–ª–µ–Ω–Ω—ã–µ —É—á–∞—Å—Ç–∫–∏
        {2, 1, 2, 10}
    };
    
    // –†–∞—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤
    double direct_time = roads[0].time();
    double detour_time = roads[1].time() + roads[2].time();
    
    std::cout << "–ü—Ä—è–º–æ–π –º–∞—Ä—à—Ä—É—Ç: " << direct_time << " —á–∞—Å–æ–≤\n";
    std::cout << "–û–±—Ö–æ–¥–Ω–æ–π –º–∞—Ä—à—Ä—É—Ç: " << detour_time << " —á–∞—Å–æ–≤\n";
    
    return 0;
}
```
4. –°–µ—Ç—å –¥–æ—Ä–æ–≥ —Å –∫—Ä–∞—Ç—á–∞–π—à–∏–º –º–∞—Ä—à—Ä—É—Ç–æ–º ‚â† –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –ø–æ–≤–æ—Ä–æ—Ç–∞–º
```
#include <vector>

struct Segment {
    int x1, y1, x2, y2;
};

int count_turns(const std::vector<Segment>& path) {
    int turns = 0;
    for (size_t i = 1; i < path.size(); ++i) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        if ((path[i].x1 - path[i-1].x2) != 0 && (path[i].y1 - path[i-1].y2) != 0) {
            turns++;
        }
    }
    return turns;
}

int main() {
    std::vector<Segment> straight_but_long = {
        {0,0, 5,0}, {5,0, 5,5}  // 1 –ø–æ–≤–æ—Ä–æ—Ç
    };
    
    std::vector<Segment> short_but_zigzag = {
        {0,0, 2,2}, {2,2, 4,0}, {4,0, 6,2}  // 2 –ø–æ–≤–æ—Ä–æ—Ç–∞
    };
    
    std::cout << "–î–ª–∏–Ω–Ω—ã–π –ø—Ä—è–º–æ–π –ø—É—Ç—å: " << count_turns(straight_but_long) << " –ø–æ–≤–æ—Ä–æ—Ç–æ–≤\n";
    std::cout << "–ö–æ—Ä–æ—Ç–∫–∏–π –∑–∏–≥–∑–∞–≥: " << count_turns(short_but_zigzag) << " –ø–æ–≤–æ—Ä–æ—Ç–æ–≤\n";
    
    return 0;
}
```
5. –ö–æ–Ω—Ç—Ä–ø—Ä–∏–º–µ—Ä—ã –¥–ª—è –∑–∞–¥–∞—á–∏ –æ —Ä—é–∫–∑–∞–∫–µ

```
#include <vector>
#include <algorithm>
#include <numeric>

bool knapsack(std::vector<int> items, int T, bool sort_ascending = false) {
    if (sort_ascending) {
        std::sort(items.begin(), items.end());
    } else {
        std::sort(items.rbegin(), items.rend());
    }
    
    int sum = 0;
    for (int item : items) {
        if (sum + item <= T) {
            sum += item;
        }
    }
    return sum == T;
}

int main() {
    std::vector<int> S = {3, 5, 7, 8};
    int T = 11;
    
    // –ü–µ—Ä–≤—ã–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π (–∏—Å—Ö–æ–¥–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫)
    std::cout << "–ü–µ—Ä–≤—ã–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π: " << knapsack(S, T) << std::endl;
    
    // –û—Ç –Ω–∞–∏–º–µ–Ω—å—à–µ–≥–æ –∫ –Ω–∞–∏–±–æ–ª—å—à–µ–º—É
    std::cout << "–û—Ç –Ω–∞–∏–º–µ–Ω—å—à–µ–≥–æ: " << knapsack(S, T, true) << std::endl;
    
    // –û—Ç –Ω–∞–∏–±–æ–ª—å—à–µ–≥–æ –∫ –Ω–∞–∏–º–µ–Ω—å—à–µ–º—É
    std::cout << "–û—Ç –Ω–∞–∏–±–æ–ª—å—à–µ–≥–æ: " << knapsack(S, T, false) << std::endl;
    
    return 0;
}
```
6. –ö–æ–Ω—Ç—Ä–ø—Ä–∏–º–µ—Ä –¥–ª—è –∑–∞–¥–∞—á–∏ –æ –ø–æ–∫—Ä—ã—Ç–∏–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–∞
```
#include <vector>
#include <set>
#include <algorithm>

using Subset = std::set<int>;
using Family = std::vector<Subset>;

Family greedy_set_cover(Family S) {
    Family cover;
    std::set<int> uncovered = {1,2,3,4,5}; // U
    
    while (!uncovered.empty()) {
        // –ù–∞—Ö–æ–¥–∏–º –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ–º —Å uncovered
        auto best_it = std::max_element(S.begin(), S.end(),
            [&](const Subset& a, const Subset& b) {
                return count_if(a.begin(), a.end(), 
                    [&](int x) { return uncovered.count(x); }) < 
                       count_if(b.begin(), b.end(), 
                    [&](int x) { return uncovered.count(x); });
            });
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤ –ø–æ–∫—Ä—ã—Ç–∏–µ
        cover.push_back(*best_it);
        
        // –£–¥–∞–ª—è–µ–º –ø–æ–∫—Ä—ã—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        for (int x : *best_it) {
            uncovered.erase(x);
        }
    }
    
    return cover;
}

int main() {
    Family S = {
        {1, 2, 3},    // –°–∞–º–æ–µ –±–æ–ª—å—à–æ–µ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ
        {4, 5},
        {1, 4},
        {2, 5}
    };
    
    Family optimal = {{1, 4}, {2, 5}}; // –û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
    
    Family greedy = greedy_set_cover(S);
    
    std::cout << "–ñ–∞–¥–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–∞–µ—Ç –ø–æ–∫—Ä—ã—Ç–∏–µ –∏–∑ " << greedy.size() << " –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤\n";
    std::cout << "–û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç " << optimal.size() << " –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤\n";
    
    return 0;
}
```
7. –ö–æ–Ω—Ç—Ä–ø—Ä–∏–º–µ—Ä –¥–ª—è –∑–∞–¥–∞—á–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –∫–ª–∏–∫–∏

```
#include <vector>
#include <set>
#include <algorithm>

using Graph = std::vector<std::set<int>>;

std::set<int> find_clique(Graph g) {
    std::vector<int> vertices(g.size());
    for (int i = 0; i < g.size(); ++i) {
        vertices[i] = i;
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å—Ç–µ–ø–µ–Ω–∏ (–≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è)
    std::sort(vertices.begin(), vertices.end(),
        [&](int a, int b) { return g[a].size() > g[b].size(); });
    
    std::set<int> clique;
    for (int v : vertices) {
        bool is_connected_to_all = true;
        for (int u : clique) {
            if (!g[v].count(u)) {
                is_connected_to_all = false;
                break;
            }
        }
        if (is_connected_to_all) {
            clique.insert(v);
        }
    }
    
    return clique;
}

int main() {
    // –ì—Ä–∞—Ñ –≤ –≤–∏–¥–µ —Å–ø–∏—Å–∫–∞ —Å–º–µ–∂–Ω–æ—Å—Ç–∏
    Graph g = {
        {1, 2, 3},    // 0 —Å–æ–µ–¥–∏–Ω–µ–Ω —Å 1,2,3
        {0, 2},       // 1 —Å–æ–µ–¥–∏–Ω–µ–Ω —Å 0,2
        {0, 1, 3},    // 2 —Å–æ–µ–¥–∏–Ω–µ–Ω —Å 0,1,3
        {0, 2, 4},    // 3 —Å–æ–µ–¥–∏–Ω–µ–Ω —Å 0,2,4
        {3}           // 4 —Å–æ–µ–¥–∏–Ω–µ–Ω —Ç–æ–ª—å–∫–æ —Å 3
    };
    
    std::set<int> clique = find_clique(g);
    
    std::cout << "–ù–∞–π–¥–µ–Ω–∞ –∫–ª–∏–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ " << clique.size() << "\n";
    std::cout << "–ù–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –∫–ª–∏–∫–∞ (0,1,2) –Ω–µ –±—ã–ª–∞ –Ω–∞–π–¥–µ–Ω–∞\n";
    
    return 0;
}
```